/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */

package playground

import java.lang.Exception

//sealed class List<out A>
//
object Nil : List<Nothing>() {
    override fun toString(): String = "Nil"
}

//
data class Cons<out A>(val head: A, val tail: List<A>) : List<A>() {
    override fun toString(): String {
        return "{ head: $head, tail: $tail }"
    }
}

sealed class List<out A> {
    companion object {
        fun <A> of(vararg aa: A): List<A> {
            val tail = aa.sliceArray(1 until aa.size)
            return if (aa.isEmpty()) Nil else Cons(aa[0], of(*tail))
        }
    }
}

// 3.1
fun <A> tail(xs: List<A>): List<A> = when (xs) {
    is Nil -> throw Exception("tail is not allowed on Nil")
    is Cons -> xs.tail
}

// 3.2
fun <A> setHead(xs: List<A>, x: A): List<A> = when (xs) {
    is Nil -> throw Exception("setHead is not allowed on Nil")
    is Cons -> Cons(x, xs)
}

// 3.3
fun <A> drop(l: List<A>, n: Int): List<A> = if (n == 0) l
else when (l) {
    is Cons -> drop(l.tail, n - 1)
    is Nil -> throw Exception("drop is not allowed on Nil")
}

// 3.4
fun <A> dropWhile(l: List<A>, block: (A) -> Boolean): List<A> = when (l) {
    is Nil -> Nil
    is Cons -> if (block(l.head)) dropWhile(l.tail, block) else l
}

fun <A> append(a1: List<A>, a2: List<A>): List<A> = when (a1) {
    is Nil -> a2
    is Cons -> Cons(a1.head, append(a1.tail, a2))
}

// 3.5
fun <A> init(l: List<A>): List<A> = when (l) {
    is Nil -> throw Exception("Nil is not allowed on init")
    is Cons ->
        if (l.tail == Nil) Nil
        else Cons(l.head, init(l.tail))
}


fun main() {
//    println(tail(List.of(1, 2, 3)))
//    println(setHead((List.of(1, 2, 3)), 4))
//    println(drop((List.of(1, 2, 3)), 1))
//    println(dropWhile((List.of(1, 2, 3))) { it <= 1 })
//    println(append(List.of(1, 2, 3), List.of(4)))
    println(init(List.of(1, 2, 3)))
}
